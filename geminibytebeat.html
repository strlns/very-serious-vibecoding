<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bytebeat Interpreter (Looping)</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
        background-color: #f4f4f9;
      }
      #oscilloscope {
        border: 2px solid #333;
        background-color: #000;
        margin-top: 20px;
      }
      button {
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        margin-right: 10px;
      }
      textarea {
        font-family: monospace;
      }
    </style>
  </head>
  <body>
    <h1>Bytebeat Interpreter</h1>

    <label for="bytebeatCode">Bytebeat Code (t):</label><br />
    <textarea
      id="bytebeatCode"
      rows="4"
      cols="60"
      placeholder="Example: t * ((t >> 10) & 42) | t * ((t >> 13) & 15)"
    >
10*(t>>7|t|t>>6)+4*(t&t>>13|t>>6)</textarea
    ><br />

    <label for="sampleRate">Sample Rate:</label>
    <select id="sampleRate">
      <option value="8000" selected>8 kHz (Classic Bytebeat)</option>
      <option value="16000">16 kHz</option>
      <option value="22050">22.05 kHz</option>
      <option value="44100">44.1 kHz</option></select
    ><br /><br />

    <button id="playButton">▶️ Play / Restart</button>
    <button id="stopButton" disabled>⏹️ Stop</button>

    <canvas id="oscilloscope" width="800" height="250"></canvas>

    <script>
      let audioCtx;
      let scriptProcessor;
      let analyser;
      let bytebeatFunc;
      let t = 0; // Global time/sample counter
      let isPlaying = false;
      let animationFrameId;

      document
        .getElementById("playButton")
        .addEventListener("click", startBytebeat);
      document
        .getElementById("stopButton")
        .addEventListener("click", stopBytebeat);

      function stopBytebeat() {
        if (isPlaying) {
          // Disconnect and clean up
          scriptProcessor.disconnect();
          analyser.disconnect();
          // Ensure audioCtx is defined before trying to close it
          if (audioCtx) {
            audioCtx.close();
          }
          cancelAnimationFrame(animationFrameId);

          isPlaying = false;
          document.getElementById("playButton").disabled = false;
          document.getElementById("stopButton").disabled = true;

          // Clear the canvas
          const canvas = document.getElementById("oscilloscope");
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "rgb(20, 20, 20)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }

      function startBytebeat() {
        // Stop any existing playback first
        stopBytebeat();

        const code = document.getElementById("bytebeatCode").value;
        const selectedSampleRate = parseInt(
          document.getElementById("sampleRate").value,
          10
        );

        // Re-initialize for play/restart
        t = 0;
        isPlaying = true;
        document.getElementById("playButton").disabled = true;
        document.getElementById("stopButton").disabled = false;

        // 1. Setup Audio Context
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: selectedSampleRate,
        });

        // 2. Analyser Node for the Oscilloscope
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;

        // 3. Script Processor Node for continuous generation
        // Buffer size impacts latency and stability; 4096 is a common choice.
        const bufferSize = 4096;
        // The ScriptProcessorNode requires the context's sampleRate if a dedicated one isn't specified
        scriptProcessor = audioCtx.createScriptProcessor(bufferSize, 0, 1);

        try {
          // Safely create the bytebeat function
          // The new Function constructor is used to evaluate the user-provided code
          bytebeatFunc = new Function("t", `return ${code};`);
        } catch (e) {
          alert("Error in Bytebeat Code: " + e.message);
          stopBytebeat();
          return;
        }

        // 4. Audio Processing Logic
        scriptProcessor.onaudioprocess = function (e) {
          const output = e.outputBuffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            // Calculate the sample
            let sample;
            try {
              sample = bytebeatFunc(t);
            } catch (e) {
              // Prevent crashing if error occurs during runtime
              sample = 0;
            }

            // Convert the 8-bit bytebeat output (0-255) to the required float range (-1.0 to 1.0)
            const byteValue = sample & 0xff;
            const normalizedValue = byteValue / 127.5 - 1.0;

            output[i] = normalizedValue;

            // Crucial for the continuous loop: increment time
            t++;
          }
        };

        // 5. Connect the nodes: Generator -> Analyser -> Speakers
        scriptProcessor.connect(analyser);
        analyser.connect(audioCtx.destination);

        // 6. Start the visualization loop
        drawOscilloscope();
      }

      // --- Oscilloscope Visualization ---
      function drawOscilloscope() {
        if (!isPlaying) return;

        const canvas = document.getElementById("oscilloscope");
        const ctx = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Array to hold the time domain data
        // Use the same fftSize as the analyser
        const bufferLength = analyser.fftSize;
        const dataArray = new Uint8Array(bufferLength);

        // The main drawing loop
        function draw() {
          // Only continue drawing if audio is playing
          if (!isPlaying) return;
          animationFrameId = requestAnimationFrame(draw);

          // Get the time domain data (waveform)
          analyser.getByteTimeDomainData(dataArray);

          // Clear and style the canvas
          ctx.fillStyle = "rgb(20, 20, 20)";
          ctx.fillRect(0, 0, WIDTH, HEIGHT);

          // Draw the waveform
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgb(0, 255, 0)"; // Green waveform
          ctx.beginPath();

          const sliceWidth = (WIDTH * 1.0) / bufferLength;
          let x = 0;

          for (let i = 0; i < bufferLength; i++) {
            // Normalize data (0-255) to canvas height (0-HEIGHT)
            const v = dataArray[i] / 128.0;
            const y = (v * HEIGHT) / 2;

            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }

            x += sliceWidth;
          }

          ctx.stroke();
        }

        draw(); // Start the first frame
      }
    </script>
  </body>
</html>
